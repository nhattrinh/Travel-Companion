import Foundation
import CoreLocation

/// Walking route generated by OpenAI
struct WalkingRoute: Codable, Identifiable {
    var id: String { routeName }
    
    let routeName: String
    let startLocationQuery: String
    let endLocationQuery: String
    let notes: String
    let totalDistanceMi: Double?
    let estimatedDurationMin: Double?
    let safetyNote: String
    let waypoints: [Waypoint]
    let directions: [DirectionSegment]
    
    /// Get formatted total distance in miles
    var totalDistanceFormatted: String {
        guard let distance = totalDistanceMi else { return "Unknown" }
        if distance < 0.1 {
            return String(format: "%.0f ft", distance * 5280)
        }
        return String(format: "%.1f mi", distance)
    }
    
    /// Get formatted total duration
    var totalDurationFormatted: String {
        guard let duration = estimatedDurationMin else { return "Unknown" }
        if duration < 60 {
            return String(format: "%.0f min", duration)
        }
        let hours = Int(duration) / 60
        let mins = Int(duration) % 60
        return "\(hours)h \(mins)min"
    }
    
    /// Get all coordinates for drawing route line
    var routeCoordinates: [CLLocationCoordinate2D] {
        waypoints.compactMap { waypoint -> CLLocationCoordinate2D? in
            guard let lat = waypoint.lat, let lng = waypoint.lng else { return nil }
            return CLLocationCoordinate2D(latitude: lat, longitude: lng)
        }
    }
    
    /// Get the start waypoint
    var startWaypoint: Waypoint? {
        waypoints.first { $0.type == .start }
    }
    
    /// Get the end waypoint
    var endWaypoint: Waypoint? {
        waypoints.first { $0.type == .end }
    }
}

/// A waypoint along the walking route
struct Waypoint: Codable, Identifiable {
    let id: String
    let name: String
    let lat: Double?
    let lng: Double?
    let description: String
    let type: WaypointType
    
    var coordinate: CLLocationCoordinate2D? {
        guard let lat = lat, let lng = lng else { return nil }
        return CLLocationCoordinate2D(latitude: lat, longitude: lng)
    }
    
    var icon: String {
        switch type {
        case .start: return "figure.walk.circle.fill"
        case .intermediate: return "mappin.circle.fill"
        case .end: return "flag.checkered.circle.fill"
        }
    }
    
    var markerColor: String {
        switch type {
        case .start: return "green"
        case .intermediate: return "blue"
        case .end: return "red"
        }
    }
}

enum WaypointType: String, Codable {
    case start
    case intermediate
    case end
}

/// A segment of walking directions between two waypoints
struct DirectionSegment: Codable, Identifiable {
    var id: String { "\(segmentIndex)-\(fromId)-\(toId)" }
    
    let segmentIndex: Int
    let fromId: String
    let toId: String
    let summary: String
    let distanceEstimateMi: Double?
    let estimatedDurationMin: Double?
    let steps: [String]
    let checkpoint: Checkpoint
    
    /// Get formatted distance for this segment in miles
    var distanceFormatted: String {
        guard let distance = distanceEstimateMi else { return "" }
        if distance < 0.1 {
            return String(format: "%.0f ft", distance * 5280)
        }
        return String(format: "%.1f mi", distance)
    }
    
    /// Get formatted duration for this segment
    var durationFormatted: String {
        guard let duration = estimatedDurationMin else { return "" }
        return String(format: "%.0f min", duration)
    }
}

/// Checkpoint at the end of a direction segment
struct Checkpoint: Codable {
    let name: String
    let lat: Double?
    let lng: Double?
    let landmarkHint: String?  // Visual cue to identify this location
    
    // Images loaded separately via ImageSearchService
    var imageUrls: [String]?
    
    var coordinate: CLLocationCoordinate2D? {
        guard let lat = lat, let lng = lng else { return nil }
        return CLLocationCoordinate2D(latitude: lat, longitude: lng)
    }
    
    // Custom coding keys since imageUrls is set client-side
    enum CodingKeys: String, CodingKey {
        case name, lat, lng, landmarkHint
    }
}
