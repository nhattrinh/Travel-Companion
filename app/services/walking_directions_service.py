"""
Walking Directions Service - Uses OpenAI to generate natural language walking directions.
"""

import os
import json
import logging
from typing import Optional, List
from pydantic import BaseModel, Field
from openai import AsyncOpenAI

logger = logging.getLogger(__name__)


# ============================================================================
# Response Models
# ============================================================================

class Checkpoint(BaseModel):
    """Checkpoint at the end of a direction segment"""
    name: str
    lat: Optional[float] = None
    lng: Optional[float] = None


class DirectionSegment(BaseModel):
    """A segment of walking directions between two waypoints"""
    segment_index: int
    from_id: str
    to_id: str
    summary: str
    distance_estimate_km: Optional[float] = None
    estimated_duration_min: Optional[float] = None
    steps: List[str]
    checkpoint: Checkpoint


class Waypoint(BaseModel):
    """A waypoint along the walking route"""
    id: str
    name: str
    lat: Optional[float] = None
    lng: Optional[float] = None
    description: str
    type: str  # "start", "intermediate", or "end"


class WalkingRoute(BaseModel):
    """Walking route generated by OpenAI"""
    route_name: str
    start_location_query: str
    end_location_query: str
    notes: str
    total_distance_km: Optional[float] = None
    estimated_duration_min: Optional[float] = None
    safety_note: str
    waypoints: List[Waypoint]
    directions: List[DirectionSegment]


# ============================================================================
# Walking Directions Service
# ============================================================================

class WalkingDirectionsService:
    """Service for generating walking directions using OpenAI."""
    
    SYSTEM_PROMPT = """You are a walking navigation planner that outputs ONLY structured JSON.

Your job:
- Take a natural-language request from the user describing a START and END location (for example: "walk from Tokyo Skytree to Tokyo Port").
- Infer a reasonable walking route between those two points.
- Propose a set of ordered waypoints along the route with approximate latitude and longitude.
- Generate clear, human-friendly walking directions between each consecutive pair of waypoints.
- Always respond with a single JSON object following the schema below.
- Do NOT include any explanation, prose, markdown, or code fences. Output raw JSON only.

====================================
JSON OUTPUT SCHEMA (REQUIRED)
====================================

You MUST return a single JSON object with this exact shape and key names:

{
  "route_name": string,
  "start_location_query": string,
  "end_location_query": string,
  "notes": string,
  "total_distance_km": number | null,
  "estimated_duration_min": number | null,
  "safety_note": string,
  "waypoints": [
    {
      "id": string,
      "name": string,
      "lat": number | null,
      "lng": number | null,
      "description": string,
      "type": "start" | "intermediate" | "end"
    }
  ],
  "directions": [
    {
      "segment_index": integer,
      "from_id": string,
      "to_id": string,
      "summary": string,
      "distance_estimate_km": number | null,
      "estimated_duration_min": number | null,
      "steps": [
        string
      ],
      "checkpoint": {
        "name": string,
        "lat": number | null,
        "lng": number | null
      }
    }
  ]
}

====================================
BEHAVIOR & RULES
====================================

- The user message will describe:
  - A start location (e.g., "Tokyo Skytree").
  - An end location (e.g., "Tokyo Port (Harumi)").
  - Optionally, extra constraints (e.g., "avoid highways", "prefer scenic", etc.).

- Use the start and end locations to:
  1. Create a human-readable "route_name", like "Tokyo Skytree to Tokyo Port (Harumi)".
  2. Fill "start_location_query" and "end_location_query" with the user's text for those locations (or a cleaned-up version).
  3. Create 3–10 waypoints total (including start and end) in logical order.
  4. Assign each waypoint an "id" and a "type":
     - "start" for the first waypoint.
     - "end" for the last waypoint.
     - "intermediate" for everything in between.
  5. For each consecutive pair of waypoints, generate one entry in "directions":
     - "from_id" is the previous waypoint id.
     - "to_id" is the next waypoint id.
     - "steps" is a list of detailed walking instructions (3–8 steps per segment).
     - "summary" is one sentence that describes the segment overall.
     - "checkpoint" should repeat the destination waypoint's name and coordinates.

- "total_distance_km" and "estimated_duration_min":
  - If you can reasonably estimate them, provide approximate numeric values.
  - If you are unsure, set them to null.
  - Use typical city walking speeds (about 4–5 km/h) for duration estimates.

- "safety_note":
  - If the walk is likely long (e.g., more than around 8–10 km), mention that it is a long walk and suggest bringing water or checking the weather.
  - Otherwise, give a brief generic walking safety note or set a concise helpful message.

- Latitude / longitude:
  - Provide approximate lat/lng for well-known landmarks if you can.
  - If you are not confident about the exact coordinates, you may approximate.
  - If you really cannot guess at all, set lat and lng to null.
  - Use decimal degrees (e.g., 35.7100, 139.8107), without degree symbols.

- Directions style:
  - Walking only (no driving, cycling, or public transit instructions).
  - Mention landmarks, neighborhoods, or big streets when relevant.
  - Assume a tourist who does not know the area.
  - Steps should be concise, sequential instructions (imperative style, e.g., "Head south along the river...", "Cross the bridge...").

- "notes":
  - Use this field for any extra helpful context inferred from the user's request (e.g., "User requested a scenic route", "Route passes through busy shopping areas").

====================================
OUTPUT FORMAT
====================================

- Output only a JSON object.
- Do NOT wrap your answer in backticks.
- Do NOT add comments, explanations, or any extra keys.
- The JSON must be syntactically valid (no trailing commas)."""

    def __init__(self):
        self.api_key = os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            logger.warning("OPENAI_API_KEY not found in environment variables")
        self.client: Optional[AsyncOpenAI] = None
    
    def _get_client(self) -> AsyncOpenAI:
        """Get or create the OpenAI client."""
        if self.client is None:
            if not self.api_key:
                raise ValueError("OPENAI_API_KEY is not configured")
            self.client = AsyncOpenAI(api_key=self.api_key)
        return self.client
    
    async def get_walking_directions(
        self,
        start_location: str,
        end_location: str
    ) -> WalkingRoute:
        """
        Get walking directions from start to end location using OpenAI.
        
        Args:
            start_location: The starting point (e.g., "Tokyo Skytree")
            end_location: The destination (e.g., "Tokyo Tower")
            
        Returns:
            WalkingRoute object with waypoints and directions
            
        Raises:
            ValueError: If API key is not configured
            Exception: If OpenAI API call fails or response parsing fails
        """
        client = self._get_client()
        
        user_prompt = f"Walk from {start_location} to {end_location}"
        
        logger.info(f"Requesting walking directions: {user_prompt}")
        
        try:
            response = await client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": self.SYSTEM_PROMPT},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            content = response.choices[0].message.content
            if not content:
                raise ValueError("Empty response from OpenAI")
            
            logger.debug(f"OpenAI response: {content[:500]}...")
            
            # Parse the JSON response
            route_data = json.loads(content)
            
            # Validate and convert to WalkingRoute model
            walking_route = WalkingRoute(**route_data)
            
            logger.info(
                f"Successfully generated route: {walking_route.route_name} "
                f"({walking_route.total_distance_km or 'unknown'} km, "
                f"{walking_route.estimated_duration_min or 'unknown'} min)"
            )
            
            return walking_route
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse OpenAI response as JSON: {e}")
            raise ValueError(f"Invalid JSON response from OpenAI: {e}")
        except Exception as e:
            logger.error(f"OpenAI API call failed: {e}")
            raise


# Singleton instance
walking_directions_service = WalkingDirectionsService()


def get_walking_directions_service() -> WalkingDirectionsService:
    """Get the walking directions service instance."""
    return walking_directions_service
